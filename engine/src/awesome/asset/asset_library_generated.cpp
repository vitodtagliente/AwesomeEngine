// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "asset_library.h"

const meta_t& AssetRecord::getTypeMeta() const { return __AssetRecordType::type().meta; }
const std::string& AssetRecord::getTypeName() const { return __AssetRecordType::type().name; }
const properties_t AssetRecord::getTypeProperties() const {
    member_address_t origin = reinterpret_cast<member_address_t>(this);
    properties_t properties;
    properties.insert(std::make_pair<std::string, Property>("id", Property("id", Property::TypeDescriptor("uuid", Property::Type::T_unknown, Property::DecoratorType::D_normalized, {}), sizeof(uuid), origin + offsetof(AssetRecord, id), {
    })));
    properties.insert(std::make_pair<std::string, Property>("path", Property("path", Property::TypeDescriptor("std::filesystem::path", Property::Type::T_unknown, Property::DecoratorType::D_normalized, {}), sizeof(std::filesystem::path), origin + offsetof(AssetRecord, path), {
    })));
    properties.insert(std::make_pair<std::string, Property>("type", Property("type", Property::TypeDescriptor("std::string", Property::Type::T_container_string, Property::DecoratorType::D_normalized, {}), sizeof(std::string), origin + offsetof(AssetRecord, type), {
    })));
    return properties;
}
std::size_t AssetRecord::getTypeSize() const { return __AssetRecordType::type().size; }

const TypeDefinition& __AssetRecordType::type()
{
    static const TypeDefinition s_typeDefinition([]() -> Type* { return new AssetRecord(); }, "AssetRecord", {
    }, sizeof(AssetRecord));
    return s_typeDefinition;
}
const meta_t& AssetDatabase::getTypeMeta() const { return __AssetDatabaseType::type().meta; }
const std::string& AssetDatabase::getTypeName() const { return __AssetDatabaseType::type().name; }
const properties_t AssetDatabase::getTypeProperties() const {
    member_address_t origin = reinterpret_cast<member_address_t>(this);
    properties_t properties;
    properties.insert(std::make_pair<std::string, Property>("records", Property("records", Property::TypeDescriptor("std::vector<std::unique_ptr<AssetRecord>>", Property::Type::T_container_vector, Property::DecoratorType::D_normalized, {Property::TypeDescriptor("AssetRecord", Property::Type::T_custom_type, Property::DecoratorType::D_unique_ptr, {})}), sizeof(std::vector<std::unique_ptr<AssetRecord>>), origin + offsetof(AssetDatabase, records), {
    })));
    return properties;
}
std::size_t AssetDatabase::getTypeSize() const { return __AssetDatabaseType::type().size; }

const TypeDefinition& __AssetDatabaseType::type()
{
    static const TypeDefinition s_typeDefinition([]() -> Type* { return new AssetDatabase(); }, "AssetDatabase", {
    }, sizeof(AssetDatabase));
    return s_typeDefinition;
}
