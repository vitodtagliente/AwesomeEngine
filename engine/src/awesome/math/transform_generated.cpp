// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "transform.h"

const reflect::meta_t& reflect::Type<math::transform>::meta()
{
    static reflect::meta_t s_meta {
    };
    return s_meta;
}
const char* const reflect::Type<math::transform>::name() { return "math::transform"; }

const reflect::properties_t& Type<math::transform>::properties()
{
    static reflect::properties_t s_properties {
        { "position", reflect::Property{ offsetof(math::transform, position), reflect::meta_t { }, "position", reflect::PropertyType{ "math::vec3", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(math::vec3), reflect::PropertyType::Type::T_native } } },
        { "rotation", reflect::Property{ offsetof(math::transform, rotation), reflect::meta_t { }, "rotation", reflect::PropertyType{ "math::vec3", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(math::vec3), reflect::PropertyType::Type::T_native } } },
        { "scale", reflect::Property{ offsetof(math::transform, scale), reflect::meta_t { }, "scale", reflect::PropertyType{ "math::vec3", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(math::vec3), reflect::PropertyType::Type::T_native } } },
        { "isStatic", reflect::Property{ offsetof(math::transform, isStatic), reflect::meta_t { }, "isStatic", reflect::PropertyType{ "bool", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(bool), reflect::PropertyType::Type::T_bool } } },
    };
    return s_properties;
}

std::size_t reflect::Type<math::transform>::size()
{
    return sizeof(math::transform);
}

void reflect::Type<math::transform>::from_string(const std::string& str, math::transform& type)
{
    reflect::encoding::ByteBuffer buffer;
    std::transform(
        std::begin(str),
        std::end(str),
        std::back_inserter(buffer),
        [](const char c)
        {
            return std::byte(c);
        }
    );
    
    reflect::encoding::InputByteStream stream(buffer);
    std::string _name;
    stream >> _name;
    if (_name != name()) return;
    
    {
        std::string pack;
        stream >> pack;
        reflect::Type<math::vec3>::from_string(pack, type.position);
    }
    {
        std::string pack;
        stream >> pack;
        reflect::Type<math::vec3>::from_string(pack, type.rotation);
    }
    {
        std::string pack;
        stream >> pack;
        reflect::Type<math::vec3>::from_string(pack, type.scale);
    }
    stream >> type.isStatic;
}

std::string reflect::Type<math::transform>::to_string(const math::transform& type)
{
    reflect::encoding::ByteBuffer buffer;
    reflect::encoding::OutputByteStream stream(buffer);
    stream << name();
    
    stream << reflect::Type<math::vec3>::to_string(type.position);
    stream << reflect::Type<math::vec3>::to_string(type.rotation);
    stream << reflect::Type<math::vec3>::to_string(type.scale);
    stream << type.isStatic;
    
    return std::string(reinterpret_cast<const char*>(&stream.getBuffer()[0]), stream.getBuffer().size());
}

void reflect::Type<math::transform>::from_json(const std::string& json, math::transform& type)
{
    std::string src{ reflect::encoding::json::Deserializer::trim(json, reflect::encoding::json::Deserializer::space) };
    
    size_t index = 0;
    std::string key;
    while ((index = reflect::encoding::json::Deserializer::next_key(src, key)) != std::string::npos)
    {
        src = src.substr(index + 2);
        src = reflect::encoding::json::Deserializer::ltrim(src, reflect::encoding::json::Deserializer::space);
        std::string value;
        index = reflect::encoding::json::Deserializer::next_value(src, value);
        if (index != std::string::npos)
        {
            if (key == "position") reflect::Type<math::vec3>::from_json(value, type.position);
            if (key == "rotation") reflect::Type<math::vec3>::from_json(value, type.rotation);
            if (key == "scale") reflect::Type<math::vec3>::from_json(value, type.scale);
            if (key == "isStatic") reflect::encoding::json::Deserializer::parse(value, type.isStatic);
            src = src.substr(index + 1);
        }
        else break;
    };
}

std::string reflect::Type<math::transform>::to_json(const math::transform& type, const std::string& offset)
{
    std::stringstream stream;
    stream << "{" << std::endl;
    stream << offset << "    " << "\"type_id\": " << "\"math::transform\"" << "," << std::endl;
    stream << offset << "    " << "\"position\": " << reflect::Type<math::vec3>::to_json(type.position, offset + "    ") << "," << std::endl;
    stream << offset << "    " << "\"rotation\": " << reflect::Type<math::vec3>::to_json(type.rotation, offset + "    ") << "," << std::endl;
    stream << offset << "    " << "\"scale\": " << reflect::Type<math::vec3>::to_json(type.scale, offset + "    ") << "," << std::endl;
    stream << offset << "    " << "\"isStatic\": " << reflect::encoding::json::Serializer::to_string(type.isStatic) << "," << std::endl;
    stream << offset << "}";
    return stream.str();
}