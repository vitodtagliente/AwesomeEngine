// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "audio_source_component.h"
#pragma warning(disable: 4100)

const char* const reflect::Enum<AudioRolloffMode>::name() { return "AudioRolloffMode"; }
const reflect::enum_values_t& reflect::Enum<AudioRolloffMode>::values()
{
    static reflect::enum_values_t s_values{
        { "None", static_cast<int>(AudioRolloffMode::None) }, 
        { "Inverse", static_cast<int>(AudioRolloffMode::Inverse) }, 
        { "Linear", static_cast<int>(AudioRolloffMode::Linear) }, 
        { "Exponential", static_cast<int>(AudioRolloffMode::Exponential) }, 
    };
    return s_values;
}

IType* const reflect::Type<AudioSourceComponent>::instantiate()
{
    return dynamic_cast<IType*>(new AudioSourceComponent());
}

const reflect::meta_t& reflect::Type<AudioSourceComponent>::meta()
{
    static reflect::meta_t s_meta {
        { "Category", "Audio" },
        { "Type", "Component" },
    };
    return s_meta;
}
const char* const reflect::Type<AudioSourceComponent>::name() { return "AudioSourceComponent"; }

const reflect::properties_t& Type<AudioSourceComponent>::properties()
{
    static reflect::properties_t s_properties {
        // Parent class Component properties
        { "enabled", reflect::Property{ offsetof(AudioSourceComponent, enabled), reflect::meta_t { }, "enabled", reflect::PropertyType{ "bool", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(bool), reflect::PropertyType::Type::T_bool } } },
        { "m_id", reflect::Property{ offsetof(AudioSourceComponent, m_id), reflect::meta_t { }, "m_id", reflect::PropertyType{ "uuid", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(uuid), reflect::PropertyType::Type::T_type } } },
        // Properties
        { "audio", reflect::Property{ offsetof(AudioSourceComponent, audio), reflect::meta_t { }, "audio", reflect::PropertyType{ "AudioAsset", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(AudioAsset), reflect::PropertyType::Type::T_type } } },
        { "loop", reflect::Property{ offsetof(AudioSourceComponent, loop), reflect::meta_t { }, "loop", reflect::PropertyType{ "bool", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(bool), reflect::PropertyType::Type::T_bool } } },
        { "pitch", reflect::Property{ offsetof(AudioSourceComponent, pitch), reflect::meta_t { }, "pitch", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "volume", reflect::Property{ offsetof(AudioSourceComponent, volume), reflect::meta_t { }, "volume", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "maxDistance", reflect::Property{ offsetof(AudioSourceComponent, maxDistance), reflect::meta_t { }, "maxDistance", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "maxGain", reflect::Property{ offsetof(AudioSourceComponent, maxGain), reflect::meta_t { }, "maxGain", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "minDistance", reflect::Property{ offsetof(AudioSourceComponent, minDistance), reflect::meta_t { }, "minDistance", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "minGain", reflect::Property{ offsetof(AudioSourceComponent, minGain), reflect::meta_t { }, "minGain", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "rolloff", reflect::Property{ offsetof(AudioSourceComponent, rolloff), reflect::meta_t { }, "rolloff", reflect::PropertyType{ "float", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(float), reflect::PropertyType::Type::T_float } } },
        { "rolloffMode", reflect::Property{ offsetof(AudioSourceComponent, rolloffMode), reflect::meta_t { }, "rolloffMode", reflect::PropertyType{ "AudioRolloffMode", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(AudioRolloffMode), reflect::PropertyType::Type::T_enum } } },
        { "useSpatialization", reflect::Property{ offsetof(AudioSourceComponent, useSpatialization), reflect::meta_t { }, "useSpatialization", reflect::PropertyType{ "bool", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(bool), reflect::PropertyType::Type::T_bool } } },
        { "m_playOnAwake", reflect::Property{ offsetof(AudioSourceComponent, m_playOnAwake), reflect::meta_t { }, "m_playOnAwake", reflect::PropertyType{ "bool", {  }, reflect::PropertyType::DecoratorType::D_raw, sizeof(bool), reflect::PropertyType::Type::T_bool } } },
    };
    return s_properties;
}

std::size_t reflect::Type<AudioSourceComponent>::size()
{
    return sizeof(AudioSourceComponent);
}

void reflect::Type<AudioSourceComponent>::from_string(const std::string& str, AudioSourceComponent& type)
{
    reflect::encoding::ByteBuffer buffer;
    std::transform(
        std::begin(str),
        std::end(str),
        std::back_inserter(buffer),
        [](const char c)
        {
            return std::byte(c);
        }
    );
    
    reflect::encoding::InputByteStream stream(buffer);
    std::string _name;
    stream >> _name;
    if (_name != name()) return;
    
    // Parent class Component properties
    stream >> type.enabled;
    {
        std::string pack;
        stream >> pack;
        type.m_id.from_string(pack);
    }
    // Properties
    {
        std::string pack;
        stream >> pack;
        type.audio.from_string(pack);
    }
    stream >> type.loop;
    stream >> type.pitch;
    stream >> type.volume;
    stream >> type.maxDistance;
    stream >> type.maxGain;
    stream >> type.minDistance;
    stream >> type.minGain;
    stream >> type.rolloff;
    {
        int pack;
        stream >> pack;
        type.rolloffMode = static_cast<AudioRolloffMode>(pack);
    }
    stream >> type.useSpatialization;
    stream >> type.m_playOnAwake;
}

std::string reflect::Type<AudioSourceComponent>::to_string(const AudioSourceComponent& type)
{
    reflect::encoding::ByteBuffer buffer;
    reflect::encoding::OutputByteStream stream(buffer);
    stream << name();
    
    // Parent class Component properties
    stream << type.enabled;
    stream << static_cast<std::string>(type.m_id);
    // Properties
    stream << static_cast<std::string>(type.audio);
    stream << type.loop;
    stream << type.pitch;
    stream << type.volume;
    stream << type.maxDistance;
    stream << type.maxGain;
    stream << type.minDistance;
    stream << type.minGain;
    stream << type.rolloff;
    stream << static_cast<int>(type.rolloffMode);
    stream << type.useSpatialization;
    stream << type.m_playOnAwake;
    
    return std::string(reinterpret_cast<const char*>(&stream.getBuffer()[0]), stream.getBuffer().size());
}

void reflect::Type<AudioSourceComponent>::from_json(const std::string& json, AudioSourceComponent& type)
{
    std::string src{ reflect::encoding::json::Deserializer::trim(json, reflect::encoding::json::Deserializer::space) };
    
    size_t index = 0;
    std::string key;
    while ((index = reflect::encoding::json::Deserializer::next_key(src, key)) != std::string::npos)
    {
        src = src.substr(index + 2);
        src = reflect::encoding::json::Deserializer::ltrim(src, reflect::encoding::json::Deserializer::space);
        std::string value;
        index = reflect::encoding::json::Deserializer::next_value(src, value);
        if (index != std::string::npos)
        {
            // Parent class Component properties
            if (key == "enabled") reflect::encoding::json::Deserializer::parse(value, type.enabled);
            if (key == "m_id") type.m_id.from_json(value);
            // Properties
            if (key == "audio") type.audio.from_json(value);
            if (key == "loop") reflect::encoding::json::Deserializer::parse(value, type.loop);
            if (key == "pitch") reflect::encoding::json::Deserializer::parse(value, type.pitch);
            if (key == "volume") reflect::encoding::json::Deserializer::parse(value, type.volume);
            if (key == "maxDistance") reflect::encoding::json::Deserializer::parse(value, type.maxDistance);
            if (key == "maxGain") reflect::encoding::json::Deserializer::parse(value, type.maxGain);
            if (key == "minDistance") reflect::encoding::json::Deserializer::parse(value, type.minDistance);
            if (key == "minGain") reflect::encoding::json::Deserializer::parse(value, type.minGain);
            if (key == "rolloff") reflect::encoding::json::Deserializer::parse(value, type.rolloff);
            if (key == "rolloffMode")
            {
                std::string temp;
                reflect::encoding::json::Deserializer::parse(value, temp);
                stringToEnum(temp, type.rolloffMode);
            }
            if (key == "useSpatialization") reflect::encoding::json::Deserializer::parse(value, type.useSpatialization);
            if (key == "m_playOnAwake") reflect::encoding::json::Deserializer::parse(value, type.m_playOnAwake);
            src = src.substr(index + 1);
        }
        else break;
    };
}

std::string reflect::Type<AudioSourceComponent>::to_json(const AudioSourceComponent& type, const std::string& offset)
{
    std::stringstream stream;
    stream << "{" << std::endl;
    stream << offset << "    " << "\"type_id\": " << "\"AudioSourceComponent\"" << "," << std::endl;
    // Parent class Component properties
    stream << offset << "    " << "\"enabled\": " << reflect::encoding::json::Serializer::to_string(type.enabled) << "," << std::endl;
    stream << offset << "    " << "\"m_id\": " << type.m_id.to_json(offset + "    ") << "," << std::endl;
    // Properties
    stream << offset << "    " << "\"audio\": " << type.audio.to_json(offset + "    ") << "," << std::endl;
    stream << offset << "    " << "\"loop\": " << reflect::encoding::json::Serializer::to_string(type.loop) << "," << std::endl;
    stream << offset << "    " << "\"pitch\": " << reflect::encoding::json::Serializer::to_string(type.pitch) << "," << std::endl;
    stream << offset << "    " << "\"volume\": " << reflect::encoding::json::Serializer::to_string(type.volume) << "," << std::endl;
    stream << offset << "    " << "\"maxDistance\": " << reflect::encoding::json::Serializer::to_string(type.maxDistance) << "," << std::endl;
    stream << offset << "    " << "\"maxGain\": " << reflect::encoding::json::Serializer::to_string(type.maxGain) << "," << std::endl;
    stream << offset << "    " << "\"minDistance\": " << reflect::encoding::json::Serializer::to_string(type.minDistance) << "," << std::endl;
    stream << offset << "    " << "\"minGain\": " << reflect::encoding::json::Serializer::to_string(type.minGain) << "," << std::endl;
    stream << offset << "    " << "\"rolloff\": " << reflect::encoding::json::Serializer::to_string(type.rolloff) << "," << std::endl;
    stream << offset << "    " << "\"rolloffMode\": " << reflect::encoding::json::Serializer::to_string(enumToString(type.rolloffMode)) << "," << std::endl;
    stream << offset << "    " << "\"useSpatialization\": " << reflect::encoding::json::Serializer::to_string(type.useSpatialization) << "," << std::endl;
    stream << offset << "    " << "\"m_playOnAwake\": " << reflect::encoding::json::Serializer::to_string(type.m_playOnAwake) << "," << std::endl;
    stream << offset << "}";
    return stream.str();
}

const reflect::meta_t& AudioSourceComponent::type_meta() const { return reflect::Type<AudioSourceComponent>::meta(); }
const char* const AudioSourceComponent::type_name() const { return reflect::Type<AudioSourceComponent>::name(); }
const reflect::properties_t& AudioSourceComponent::type_properties() const { return reflect::Type<AudioSourceComponent>::properties(); }
AudioSourceComponent::operator std::string() const { return reflect::Type<AudioSourceComponent>::to_string(*this); }
void AudioSourceComponent::from_string(const std::string& str)
{
    reflect::Type<AudioSourceComponent>::from_string(str, *this);
    type_initialize();
}
void AudioSourceComponent::from_json(const std::string& json)
{
    reflect::Type<AudioSourceComponent>::from_json(json, *this);
    type_initialize();
}
std::string AudioSourceComponent::to_json(const std::string& offset) const { return reflect::Type<AudioSourceComponent>::to_json(*this, offset); }